C++ Primer 学习笔记
==================

****
## 目录
* [第一章](#第一章)
* [第二章](#第二章)
* [第三章](#第三章)
* [第四章](#第四章)
* [第五章](#第五章)
* [第六章](#第六章)
* [第七章](#第七章)
-----------------
### 第一章
`cerr`输出警告和错误信息

`clog`输出程序运行时的一般性信息

* 执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的         
* 执行后置递增和递减操作时，变量的值都是在语句被求值之后改变的        
``` C++
int num1 = 2;
int num2 = 20;
int num3 = --num1 + num2;//等于21
int num4 = num1 + num2;//等于21
```
``` C++
int num1 = 2;
int num2 = 20;
int num3 = num1-- + num2;//等于22
int num4 = num1 + num2;//等于21
```
事先知道循环次数用`for`，不知道用`while`。`for`循环头由三个部分组成：**一个初始化语句**、**一个循环条件**、**一个表达式**。    
* 统计在输入每个值连续出现了多少次
``` C++
#include<iostream>
using namespace std;

int main()
{
    //currVal时我们正在统计的数；我们将读入的新值存入val
    int currVal = 0, val = 0;
    if (cin >> currVal){
        int cnt = 1;                            //保存我们正在处理的当前值的个数
        while(cin >> val){                      //读取剩余的数
            if(val == currVal)                  //如果值相同
                ++cnt;                          //将cnt加1
            else{                               //否则打印前一个值的个数
                cout << currVal << " occurs "
                << cnt << " times" << endl;
                currVal = val;                  //记住新值
                cnt =1;                         //重置计数器
            }
        }//while循环在这里结束
        //记住打印文件中最后一个值的个数
        cout << currVal << " occurs "
        << cnt << " times" << endl;
    }//最外层if语句在这里结束
    return 0;
}

输入：
42 42 42 42 42 55 55 62 100 100 100
输出：
42 occurs 5 times
55 occurs 2 times
62 occurs 1 times
100 occurs 3 times
```
-------------------------------
### 第二章
当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。       
* 从数学角度：取模运算时，对于负数，应该加上被除数的整数倍，使结果大雨或等于0之后，再进行运算。       
* 从计算机存储角度： 计算机中负数是以补码形式存储的，`-1的补码11111111`，转换成无符号数即是255的二进制编码。        
``` C++
(-1)%256=(-1+256)%256=255
```
表达式中既有带符号类型又有无符号类型，则带符号数会自动低转换成无符号数。       
* 如果反斜杠线\后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列。
```C++
\1234表示2个字符，即八进制数123对应的字符以及字符4.
```
C++中程序员们在很多场合都会使用对象(object）这个名词。通常情况下，**对象是指一块能存储数据并具有某种类型的内存空间**。     
**声明**使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而**定义**负责创建与名字相关的实体。变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。        
如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`。     
```C++
extern int i;//声明i而非定义i
```
Note:变量只能被**定义一次**，但是可以被**多次声明**。       
`for`循环中的`i`是局部变量，出了循环就没用了。    
**引用**为对象起了另外一个名字。无法另引用重新绑定另外一个对象。引用的类型都要和与之绑定的对象严格匹配。           
```C++
int &refVal;        //报错：引用必须被初始化
int &refVal2 = 10;  //报错：引用类型的初始值必须是一个对象
```
**指针**是指向另外一种类型的复合类型。     
>指针和引用的不同点。
>其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针对声明周期内它可以先后指向几个不同的对象。
>其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

>key difference:
>1.引用是已经存在的对象的另一个名称，指针本身就是一个对象。
>2.初始化后，引用仍然绑定到它的初始对象，无法重新绑定引用来引用不同的对象，一个指针可以被分配和复制。
>3.引用总是获取引用最初被绑定的对象，一个指针可以在它的生命周期中指向几个不同的对象。
>4.必须初始化引用，指针在定义的时候可以不初始化。
```C++
int *p = &ival; //p存放变量ival的地址，或者说p是指向变量ival的指针
```
```C++
int *p = nullptr; //等价于int *p = 0;
p = 0 ;//指向的地址变了，不指向任何对象了
*p = 0;//指向的地址内的值变了
```
`void*`是一种特殊的指针类型，可用于存放任意对象的地址。**不能直接操作void\*指针所指的对象，因为我们并不知道这个对象到底是个什么类型，也就无法确定能在这个对象上做哪些操作。**
* 指向指针的指针      
```C++
int *pi = &val;  //pi指向一个int型的数
int **ppi = &pi; //ppi指向一个int型的指针
```
* 指向指针的引用      
引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。     
```C++
int i = 42;
int *p;            //p是一个int型指针
int *&r = p;       //r是一个对指针p的引用

r = &i;            //r引用了一个指针，因此给r赋值&i就是令p指向i
*r = 0;            //解引用r得到i，也就是p指向的对象，将i的值改为0
```
要理解r的类型到底是什么，最简单的办法是从**右向左阅读**r的定义。离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号\*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。    
Note：面对一条比较复杂的指针或者引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。      
const对象一旦创建后其值就不能再改变，所以const对象**必须初始化**
```C++
const int i = get_size();  //正确：运行时初始化
const int j = 42;          //正确：编译时初始化
const int k;               //错误：k是一个未经初始化的常量
```
Note：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。只在一个文件定义const，而在其他多个文件中声明并使用它。     
```C++
//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
//file_1.h头文件
extern const int bufSize; //与file_1.cc中定义的bufSize是同一个
```
* const的引用    
与普通引用不同的是，对常量对引用不能被用作修改它所绑定的对象：
```C++
const int ci =1024;
const int &r1 = ci; //正确：引用及其对应的对象都是常量
r1 = 42;            //错误：r1是对常量对引用
int &r2 = ci；      //错误：试图让一个非常量引用指向一个常量对象
```
* 对const的引用可能引用一个并非const的对象     
必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：   
```C++
int i = 42;    
int &r1 = i;         //引用ri绑定对象i
const int &r2 = i;   //r2也绑定对象i,但是不允许通过r2修改i的值
r1 = 0;              //r1并非常量，i的值修改为0
r2 = 0;              //错误：r2是一个常量引用
```
r2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。      
* 指针和const    
类似于常量引用，指向常量的指针不能用于改变其所指对象的值。**要想存放常量对象的地址，只能使用指向常量的指针**。     
```C++
const double pi = 3.14;      //pi是个常量，它的值不能改变
double *ptr = &pi;           //错误：ptr是一个普通指针
const double *cptr = &pi;    //正确：cptr可以指向一个双精度常量
*cptr = 42;                  //错误：不能给*cptr赋值
```   
之前提到，指针的类型必须与其所指向的类型一致，**但是有两个例外**。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象：    
```C++
double dval = 3.14;  //dval是一个双精度浮点数，它的值可以改变
cptr = &dval;        //正确：但是不能通过\*cptr改变dval的值
```
和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过改变对象的值，而没有规定那个对象的值不能通过其他途径改变。     
* const指针
指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。**常量指针必须初始化**，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址就不能再改变了。      
```C++
int errNumb = 0;
int *const curErr = &errNumb;       //curErr将一直指向errNumb
const double pi = 3.14159;
const double *const pip = &pi;      //pip是一个指向常量对象的常量指针
```   
**指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型**。       
* 顶层const     
**顶层const**表示指针本身是个常量，而用名词**底层const**表示指针所指的对象是一个常量。更一般的，**顶层const**可以表示任意的对象是常量，这一点对任何数据类型都适用，如算数类型、类、指针等。**底层const**则与指针和引用等复合类型的基本类型部分有关。**比较特殊的是指针类型既可以是顶层const也可以是底层const，这一类型和其他相比区别明显：**       
```C++
int i = 0;
int *const p1 = &i;       //不能改变p1的值，这是一个顶层const
const int ci = 42;        //不能改变ci的值，这是一个顶层const
const int *p2 = &ci;      //允许改变p2的值，这是一个底层const
const int *const p3 = p2;  //靠右的const是顶层const，靠左的const是底层const
const int &r = ci;        //用于声明的引用const都是底层const
i = ci;         //正确：拷贝ci的值，ci是一个顶层const，对此操作无影响
p2 = p3;        //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响
int *p = p3;    //错误：p3包含底层const定义，而p没有。 当执行对象的拷贝操作时候，拷入和拷出的对象必须具有相同的底层const资格
p2 = p3;       //
p2 = &i;
int &r = ci;
const int &r2 = i;
```      






































